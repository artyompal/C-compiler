
 TODO:


 Фиксы:

 * Надо написать push/pop аллокатора.

 * Надо сделать вычисление таблиц анализатора ленивым.

 * Надо оптимизировать сдвиг и умножение в адрес, когда возможно.

 * Константы должны перемещаться вниз среди эквивалентных инструкций (т.е. инструкции типа add reg,const; add reg,reg 
   должны меняться местами).

 * Надо написать генерацию LEA из операндов.

 * Надо объединять ADD/SUB с константой с LEA.

 * Надо при оптимизации push_arg оптимизировать целочисленные аргументы тоже - это уменьшит суммарное число инструкций.


 Кеширование:
 
 * При выходе из области видимости указателя все зависимые регистровые переменные должны быть сброшены в память.

 * При изменении указателя все зависимые регистровые переменные должны быть сброшены в память.

 * Надо вычислять явно конфликтующие закешированные адреса; перед записью одного из них остальные должны быть сброшены.

 * Надо вычислять множество указателей, потенциально конфликтующих с закешированными данными.
   Перед записью по такому указателю все потенциально конфликтующие регистровые переменные должны быть сброшены в память.

 * Для каждого использования закешированной переменной, если среди доступных определений есть выгруженные, то она должна
   быть перезачитана.

                                                                                                                         
 Аллокатор регистров:

 * Нужно изменить аллокатор регистров таким образом, чтобы регистры, которые не надо сохранять, имели больший приоритет,
   когда приходится выбрать один из регистров для выгрузки.

 * Надо проверять модификацию переменной (флаг dirty) через ио-цепочки.

 * Возможно, надо заменить маску освобождённых регистров на массив.

 * И вообще, надо переписать аллокатор регистров таким образом, чтобы минимизировать число операций с памятью.
   Когда создаётся слишком много регистровых переменных, порождается множество конфликтов и много лишних операций загрузки/сохранения.


 Общие алгоритмы:

 * Надо преобразовывать трёхадресный код внутри базовых блоков таким образом, чтобы минимизировать требующееся число регистров
   (например, используя алгоритм динамического программирования из Дракона).

 * Надо проверить факт использования каждой стековой переменной после раскраски регистров и написать дефрагментацию стекового фрейма.

 * Нужно проводить межпроцедурный анализ использования указателей, чтобы анализировать указатели на отстутствие алиасинга.

 * Надо написать векторизацию кода над 2-4х-мерными векторами. Для того, чтобы проверить, что эта операция стала улучшением
   кода, нужно написать клонирование кода функции и вычисление метрики (хотя бы как числа инструкций, но предпочтительнее
   вычислять ожидаемое время выполнения с учётом циклов).                                                                                                                      но 

 * Надо выносить из if-else инструкции, общие для обеих веток.

 * Можно распознавать простейшие условные конструкции, такие, как min/max. Кроме того, надо переделывать простые IF,
   содержащие несколько MOV, в условные, однако нужно доказывать, что в сгенерированном коде не добавился access violation.

 * Надо написать построение графа циклов для потока.

 * Нужно написать проверку графа на приводимость.

 * Нужно вынести константные вычисления из цикла. Вещественное деление в цикле должно быть также распознано, как подвыражение.

 * Надо написать устранение общих подвыражений.

 * Можно освободить регистр ebp, если отказаться от стек-фреймов в статических функциях.
   Можно одним проходом после инлайнинга перевести всю адресацию с ebp на esp.

 * Надо гарантировать уникальность соответствия меток и переходов. (На самом деле, нужно только для переходов вперёд).


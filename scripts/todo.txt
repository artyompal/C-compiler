
 TODO:


 Мелкие оптимизации:

 * Надо переделать сборку regressive-тестов на cl/link в обход devenv.

 * Надо добавить стадию оптимизации после раскраски. Надо удалять мёртвый код после раскраски регистров.

 * Надо оптимизировать множественные add/sub esp,4 в одну инструкцию


 Специфичные для данного теста оптимизации:

 * Нужно заменять вещественные деления на константу на умножения.

 * Надо не генерировать инструкцию test/cmp,0, когда результат уже есть во флагах.

 * Надо выносить из if-else инструкции, общие для обеих веток.

 * Надо починить или дописать код, индексирующий указатели с использованием богатства режимов адресации x86.

 * В тесте надо сменить всю арифметику на беззнаковую и убрать лишний AND. Тогда можно будет оптимизировать
   кодовые последовательности, маскирующие первый и второй младшие байты.


 Общие алгоритмы:

 * Надо удалить из проекта всякие упоминания о reg_first_write/reg_last_read/reg_changes_value.

 * После этого можно будет поменять везде проверку результата на bincode_extract_pseudoregs_modified_by_insn.
   Также эта функция должна узнать о MUL/DIV/IDIV и о регистре ECX для MOVSD.

 * Нужно научить аллокатор регистров освобождать регистры тогда, когда это можно делать. Это даст ему больше свободы для работы.
 
 * Надо написать построение графа циклов для потока.

 * Нужно написать проверку графа на приводимость.

 * Нужно вынести константные вычисления из цикла.

 * Надо написать устранение общих подвыражений.

 * Можно освободить регистр ebp, если отказаться от стек-фреймов в статических функциях.
   Можно одним проходом после инлайнинга перевести всю адресацию с ebp на esp.

 * Надо кешировать доступ к часто используемым переменным в памяти.
   Регистровые переменные должны иметь возможность оказаться также в часто используемых структурах и в произвольных адресуемых
   областях памяти, а переменные в стековом фрейме должны стать частным случаем.

 * Надо ограничивать такое кеширование в соответствии с правилами алиасинга, а лучше ограничивать любыми записями в память.

 * Надо гарантировать уникальность соответствия меток и переходов. (На самом деле, нужно только для переходов вперёд).

 * Надо удалять мёртвые присваивания.


 Оценочная функция:

 * Надо написать оценочную функцию для примерного вычисления времени выполнения функции.

 * Желательно детектировать количество итераций в простейших циклах. Тогда можно будет усовершенствовать оценочную функцию.

 * Надо написать функцию клонирования всего кода функции. После этого станет возможно перебирать варианты кодогенерации.

 * Возможно, не все переменные должны быть регистровыми. Решение об этом можно принимать на основе оценочной функции.

 * Можно улучшить алгоритм вытеснения регистров, имея оценочную функцию с информацией о внутренних циклах,
   с тем, чтобы не помещать код сохранения/восстановления регистра во внутренний цикл.

 * Желательно не выделять регистры esi/edi, когда можно обойтись несохраняемыми регистрами.
   Так же желательно не выделять регистры eax/edx/ecx под регистровые переменные, когда они активно используются 
   для арифметики.



#define YYSTACK_ALLOC malloc


/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define yyerrok         (yyerrstatus = 0)
#define yyclearin       (yychar = YYEMPTY)
#define YYEMPTY         -2
#define YYEOF           0
#define YYACCEPT        goto yyacceptlab
#define YYABORT         goto yyabortlab
#define YYERROR         goto yyerrlab1
/* Like YYERROR except do call yyerror.
   This remains here temporarily to ease the
   transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define YYFAIL          goto yyerrlab
#define YYRECOVERING()  (!!yyerrstatus)
#define YYBACKUP(token, value) \
do                                                              \
  if (yychar == YYEMPTY && yylen == 1)                          \
    { yychar = (token), yylval = (value);                       \
      yychar1 = YYTRANSLATE (yychar);                           \
      YYPOPSTACK;                                               \
      goto yybackup;                                            \
    }                                                           \
  else                                                          \
    { yyerror ("syntax error: cannot back up"); YYERROR; }      \
while (0)

#define YYTERROR        1
#define YYERRCODE       256

#ifndef YYPURE
#define YYLEX           yylex()
#endif

#ifdef YYPURE
#ifdef YYLSP_NEEDED
#ifdef YYLEX_PARAM
#define YYLEX           yylex(&yylval, &yylloc, YYLEX_PARAM)
#else
#define YYLEX           yylex(&yylval, &yylloc)
#endif
#else /* not YYLSP_NEEDED */
#ifdef YYLEX_PARAM
#define YYLEX           yylex(&yylval, YYLEX_PARAM)
#else
#define YYLEX           yylex(&yylval)
#endif
#endif /* not YYLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef YYPURE

int     yychar;                 /*  the lookahead symbol                */
YYSTYPE yylval;                 /*  the semantic value of the           */
                                /*  lookahead symbol                    */

#ifdef YYLSP_NEEDED
YYLTYPE yylloc;                 /*  location data for the lookahead     */
                                /*  symbol                              */
#endif

int yynerrs;                    /*  number of parse errors so far       */
#endif  /* not YYPURE */

#if YYDEBUG != 0
int yydebug;                    /*  nonzero means print parse trace     */
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  YYINITDEPTH indicates the initial size of the parser's stacks       */

#ifndef YYINITDEPTH
#define YYINITDEPTH 200
#endif

/*  YYMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if defined(YYMAXDEPTH) && YYMAXDEPTH == 0
#undef YYMAXDEPTH
#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 10000
#endif


#if YYDEBUG != 0
#define YYPRINTF(params)         printf params;
#define YYMESSAGE(params)        if (yydebug) printf params;
#else
#define YYPRINTF(params)
#define YYMESSAGE(params)
#endif



int yyparse(void)
{
   register int yystate;
   register int yyn;
   register short *yyssp;
   register YYSTYPE *yyvsp;
   int yyerrstatus;        /* number of tokens to shift before error
                           messages enabled              */
   int yychar1 = 0;        /* lookahead token as an internal (translated)
                           token number                  */

   short yyssa[YYINITDEPTH];  /* the state stack                  */
   YYSTYPE yyvsa[YYINITDEPTH];   /* the semantic value stack         */

   short *yyss    = yyssa; /* refer to the stacks thru separate pointers */
   YYSTYPE *yyvs  = yyvsa; /*  to allow yyoverflow to reallocate them elsewhere */

#ifdef YYLSP_NEEDED
   YYLTYPE yylsa[YYINITDEPTH];   /*  the location stack              */
   YYLTYPE *yyls  = yylsa;
   YYLTYPE *yylsp;
#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
#else
#define YYPOPSTACK   (yyvsp--, yyssp--)
#endif

   int yystacksize      = YYINITDEPTH;
   int yyfree_stacks = 0;

#ifdef YYPURE
   int yychar;
   YYSTYPE yylval;
   int yynerrs;
#ifdef YYLSP_NEEDED
   YYLTYPE yylloc;
#endif
#endif

   YYSTYPE yyval;          /* the variable used to return         */
                        /* semantic values from the action     */
                        /* routines                   */

   int yylen;

   YYMESSAGE(("Starting parse\n"));

   yystate     = 0;
   yyerrstatus = 0;
   yynerrs     = 0;
   yychar      = YYEMPTY;     /* Cause a token to be read.        */

   /*
    * Initialize stack pointers.
    * Waste one element of value and location stack
    * so that they stay on the same level as the state stack.
    * The wasted elements are never initialized.
    */

   yyssp    = yyss - 1;
   yyvsp    = yyvs;
#ifdef YYLSP_NEEDED
   yylsp    = yyls;
#endif

   /*
    * Push a new state, which is found in  yystate  .
    */
   /*
    * In all cases, when you get here, the value and location stacks
    * have just been pushed. So pushing a state here evens the stacks.
    */


yynewstate:

   *++yyssp = (short) yystate;

   if (yyssp >= yyss + yystacksize - 1) {
      /*
       * Give user a chance to reallocate the stack
       */
      /* Use copies of these so that the &'s don't force the real ones
       * into memory.
       */

      YYSTYPE *yyvs1 = yyvs;
      short *yyss1   = yyss;
#ifdef YYLSP_NEEDED
      YYLTYPE *yyls1 = yyls;
#endif

      /* Get the current used size of the three stacks, in elements. */
      int size    = yyssp - yyss + 1;


#ifdef yyoverflow
      /*
       * Each stack pointer address is followed by the size of the data
       * in use in that stack, in bytes.
       */
#ifdef YYLSP_NEEDED
      /*
       * This used to be a conditional around just the two extra args,
       * but that might be undefined if yyoverflow is a macro.
       */

      yyoverflow("parser stack overflow",
            &yyss1, size * sizeof (*yyssp),
            &yyvs1, size * sizeof (*yyvsp),
            &yyls1, size * sizeof (*yylsp),
            &yystacksize);
#else
      yyoverflow("parser stack overflow",
            &yyss1, size * sizeof (*yyssp),
            &yyvs1, size * sizeof (*yyvsp),
            &yystacksize);
#endif

      yyss  = yyss1;
      yyvs  = yyvs1;

#ifdef YYLSP_NEEDED
      yyls  = yyls1;
#endif


#else /* no yyoverflow */


      /*
       * Extend the stack our own way.
       */

      if (yystacksize >= YYMAXDEPTH) {
         yyerror("parser stack overflow");

         if (yyfree_stacks) {
            free(yyss);
            free(yyvs);

#ifdef YYLSP_NEEDED
            free(yyls);
#endif
         }

         return 2;
      }

      yystacksize *= 2;
      if (yystacksize > YYMAXDEPTH) yystacksize = YYMAXDEPTH;

#ifndef YYSTACK_USE_ALLOCA
      yyfree_stacks = 1;
#endif

      yyss  = (short *) YYSTACK_ALLOC( yystacksize * sizeof(*yyssp) );
      memcpy(yyss, yyss1, size * sizeof(*yyssp) );
      yyvs  = (YYSTYPE *) YYSTACK_ALLOC( yystacksize * sizeof(*yyvsp) );
      memcpy(yyvs, yyvs1, size * sizeof(*yyvsp) );

#ifdef YYLSP_NEEDED
      yyls  = (YYLTYPE *) YYSTACK_ALLOC( yystacksize * sizeof(*yylsp) );
      memcpy(yyls, yyls1, size * sizeof(*yylsp) );
#endif


#endif /* no yyoverflow */


      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;

#ifdef YYLSP_NEEDED
      yylsp = yyls + size - 1;
#endif

      YYMESSAGE(("Stack size increased to %d\n", yystacksize));
      if (yyssp >= yyss + yystacksize - 1) YYABORT;
   }

   YYMESSAGE(("Entering state %d\n", yystate));
   goto yybackup;


   yybackup:

/*
 * Do appropriate processing given the current state.
 *
 * Read a lookahead token if we need one and don't already have one.
 */

/* yyresume: */

   /*
    * First try to decide what to do without reference to lookahead token.
    */

   yyn = yypact[yystate];
   if (yyn == YYFLAG) goto yydefault;

   /*
    * Not known => get a lookahead token if don't already have one.
    */

   /*
    * yychar is either YYEMPTY or YYEOF
    * or a valid token in external form.
    */

   if (yychar == YYEMPTY) {
      YYMESSAGE(("Reading a token: "));
      yychar = YYLEX;
   }

   /*
    * Convert token to internal form (in yychar1) for indexing tables with
    */

   if (yychar <= 0) {         /* This means end of input.         */
      yychar1  = 0;
      yychar   = YYEOF;    /* Don't call YYLEX any more        */

      YYMESSAGE(("Now at end of input.\n"));
   }
   else {
      yychar1 = YYTRANSLATE(yychar);
      YYMESSAGE(("Next token is %d (%s)\n", yychar, yytname[yychar1] ));
   }

   yyn   += yychar1;
   if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) goto yydefault;

   yyn   = yytable[yyn];

   /*
    * yyn is what to do for this token type in this state.
    * Negative => reduce, -yyn is rule number.
    * Positive => shift, yyn is new state.
    * New state is final state => don't bother to shift, just return success.
    * 0, or most negative number => error.
    */

   if (yyn < 0) {
      if (yyn == YYFLAG) goto yyerrlab;
      yyn = -yyn; goto yyreduce;
   }
   else if (yyn == 0)
      goto yyerrlab;

   if (yyn == YYFINAL) YYACCEPT;

   /*
    * Shift the lookahead token.
    */

   YYMESSAGE(("Shifting token %d (%s), ", yychar, yytname[yychar1] ));

   /*
    * Discard the token being shifted unless it is eof.
    */
   if (yychar != YYEOF) yychar = YYEMPTY;
   *++yyvsp = yylval;

#ifdef YYLSP_NEEDED
   *++yylsp = yylloc;
#endif

   /*
    * count tokens shifted since error; after three, turn off error status.
    */
   if (yyerrstatus) yyerrstatus--;
   yystate = yyn; goto yynewstate;

   /*
    * Do the default action for the current state.
    */

yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0) goto yyerrlab;

   /*
    * Do a reduction.
    * yyn is the number of a rule to reduce with.
    */

yyreduce:
   yylen = yyr2[yyn];
   if (yylen > 0)
      yyval = yyvsp[1-yylen]; /* implement default value of the action */

#if YYDEBUG != 0
   if (yydebug) {
      int i;

      YYPRINTF(("Reducing via rule %d (line %d), ", yyn, yyrline[yyn] ));

      /*
       * Print the symbols being reduced, and their result.
       */

      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
         YYPRINTF(("%s ", yytname[yyrhs[i]] ));

         YYPRINTF((" -> %s\n", yytname[yyr1[yyn]] ));
    }
#endif

$   /* the action file gets copied in in place of this dollarsign */

#line 421 "e:\\work\\programs\\current\\lang_tools\\bison\\files\\bison.simple"

   yyvsp -= yylen;
   yyssp -= yylen;

#ifdef YYLSP_NEEDED
   yylsp -= yylen;
#endif

#if YYDEBUG != 0
   if (yydebug) {
      short *ssp1 = yyss - 1;
         YYPRINTF(("state stack now"));

      while (ssp1 != yyssp)
         YYPRINTF((" %d", *++ssp1));

         YYPRINTF(("\n"));
   }
#endif

   *++yyvsp = yyval;

#ifdef YYLSP_NEEDED
   yylsp++;

   if (yylen == 0) {
      yylsp->first_line = yylloc.first_line;
      yylsp->first_column  = yylloc.first_column;
      yylsp->last_line  = (yylsp-1)->last_line;
      yylsp->last_column   = (yylsp-1)->last_column;
      yylsp->text       = 0;
   }
   else {
      yylsp->last_line  = (yylsp+yylen-1)->last_line;
      yylsp->last_column   = (yylsp+yylen-1)->last_column;
    }
#endif

   /*
    * Now "shift" the result of the reduction.
     * Determine what state that goes to,
     * based on the state we popped back to
     * and the rule number reduced by.
     */

   yyn      = yyr1[yyn];
   yystate  = yypgoto[yyn - YYNTBASE] + *yyssp;

   if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
      yystate = yytable[yystate];
   else
      yystate = yydefgoto[yyn - YYNTBASE];

   goto yynewstate;


yyerrlab:   /* here on detecting error */

   if ( !yyerrstatus ) {
      /*
       * If not already recovering from an error, report this error.
       */

      ++yynerrs;

#ifdef YYERROR_VERBOSE
      yyn = yypact[yystate];
      if (yyn > YYFLAG && yyn < YYLAST) {
         int size = 0;
         char *msg;
         int x, count;

         count = 0;

         /*
          * Start X at -yyn if nec to avoid negative indexes in yycheck.
          */

         for (x = (yyn < 0 ? -yyn : 0);
               x < (sizeof(yytname) / sizeof(char *)); x++)
            if (yycheck[x + yyn] == x)
               size += strlen(yytname[x]) + 15 /*, count++ */;

         msg = (char *) malloc(size + 15);
         if ( msg ) {
            strcpy(msg, "parse error");

            if (count < 5) {
               count = 0;

               for (x = (yyn < 0 ? -yyn : 0);
                     x < (sizeof(yytname) / sizeof(char *)); x++)
                  if (yycheck[x + yyn] == x) {
                     if (yytname[x][0] == '\'') {
                        strcat(msg, count == 0 ? ", expecting " : " or ");
                        strcat(msg, yytname[x]);
                     } else {
                        strcat(msg, count == 0 ? ", expecting `" : " or `");
                        strcat(msg, yytname[x]);
                        strcat(msg, "'");
                     }

                     count++;
                  }
            }

            yyerror(msg);
            free(msg);
         }
         else
            yyerror ("parse error; also virtual memory exceeded");
      }
      else
         yyerror("parse error");
#else
      yyerror("parse error");
#endif   /* YYERROR_VERBOSE */
   }

   goto yyerrlab1;
   yyerrlab1:     /* here on error raised explicitly by an action */

   if (yyerrstatus == 3) {
      /*
       * if just tried and failed to reuse lookahead token after an error,
       * discard it.
       */

      /*
       * return failure if at end of input
       */

      if (yychar == YYEOF) YYABORT;

      YYMESSAGE(("Discarding token %d (%s).\n", yychar, yytname[yychar1] ));

      yychar = YYEMPTY;
   }

   /*
    * Else will try to reuse lookahead token
     * after shifting the error token.
     */

   yyerrstatus = 3;        /* Each real token shifted decrements this   */

   goto yyerrhandle;
   yyerrdefault:           /* current state does not do anything     *
                         * special for the error token.        */

yyerrpop:                  /* pop the current state because it cannot   *
                         * handle the error token              */

   if (yyssp == yyss) YYABORT;
   yyvsp--;
   yystate  = *--yyssp;

#ifdef YYLSP_NEEDED
   yylsp--;
#endif

#if YYDEBUG != 0
   if (yydebug) {
      short *ssp1 = yyss - 1;

      YYPRINTF(("Error: state stack now"));

      while (ssp1 != yyssp)
         YYPRINTF((" %d", *++ssp1));

      YYPRINTF(("\n"));
   }
#endif

yyerrhandle:

   yyn   = yypact[yystate];
   if (yyn == YYFLAG) goto yyerrdefault;

   yyn   += YYTERROR;
   if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR) goto yyerrdefault;

   yyn = yytable[yyn];
   if (yyn < 0) {
      if (yyn == YYFLAG) goto yyerrpop;
      yyn = -yyn; goto yyreduce;
   }
   else if (yyn == 0)
      goto yyerrpop;

   if (yyn == YYFINAL) YYACCEPT;

   YYMESSAGE(("Shifting error token, "));

   *++yyvsp = yylval;

#ifdef YYLSP_NEEDED
   *++yylsp = yylloc;
#endif

   yystate     = yyn;
   goto yynewstate;


yyacceptlab:
   /*
    * YYACCEPT comes here.
    */

   if (yyfree_stacks) {
      free(yyss);
      free(yyvs);

#ifdef YYLSP_NEEDED
      free (yyls);
#endif
   }

   return 0;

yyabortlab:
   /*
    * YYABORT comes here.
    */

   if (yyfree_stacks) {
      free(yyss);
      free(yyvs);

#ifdef YYLSP_NEEDED
      free (yyls);
#endif
   }

   return 1;
}

